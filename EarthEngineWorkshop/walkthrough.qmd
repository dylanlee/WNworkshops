---
title: "An introduction to Google Earth Engine"
title-slide-attributes:
  data-background-image: ./Images/_MODIS_Pic.jpg 
  data-background-size: cover
  data-background-opacity: "0.5"
format: 
  revealjs:
    width: 950
    height: 950
    theme: dark
    code-overflow: wrap
    #self-contained: true
css: walkthrough.css
---

## What is Google Earth Engine?

![](./Images/EarthEngineSplashPage.png)

::: {.notes}
Google Earth Engine is a platform for geospatial analysis. It provides access to satellite imagery and other remote sensing data. Earth Engine simplifies the task of processing geospatial data.
:::

## Earth Engine Code Editor

![](./Images/EarthEngineEditor.png)

::: {.notes}
The Earth Engine Code Editor is a web-based IDE for accessing the Earth Engine datasets and analysis library using javascript. We're going to do a quick walkthrough of the editor and some of its capabilities.
::: 

## Inserting data using the search bar

![](./Videos/SearchBar.gif){fig-align="center"}

::: {.notes}
The search bar in Earth Engine Editor allows you to easily find and *import* datasets and satellite imagery for analysis. Here we're importing landsat 8 reflectance data.
:::

## Browsing library reference

![](./Videos/docquery.gif){fig-align="center"}

## The scripts pane

![](./Videos/openscript.gif){fig-align="center"}

::: {.notes}
The scripts tab allows you to access your scripts.
:::

## The assets pane

![](./Videos/ImportingAssets.gif){fig-align="center"}

::: {.notes}
This tab allows you to upload your own geospatial data into the editor. Here we will upload a shape file from the US flood inundation map repostiory.
verbally walk through:
- uploading assets. Mention the task pane as place where uploading and downloading takes place
- opening script to display vector fill map
- importing assets. Show that asset shows up in script
- run script then going to map to view asset
:::

## The inspector

![](./Videos/inspector.gif){fig-align="center"}

::: {.notes}
The inspector allows you to examine the assets being used or produced by a script.
- go over how the vertices of each of the polygons in the flood fill map can be accessed in the 
- go over examining the metadata fields of the flood
:::

## The console

![](./Videos/console.gif){fig-align="center"}

::: {.notes}
The console is where you can send messages to from your program. The console is also where error messages appear.
:::

## The map pane

![](./Videos/MapPane.gif){fig-align="center"}

::: {.notes}
- In the map pane you can draw points, lines, or polygons and have those geometries show up in your script.
- The map pane also has the ability to add and remove layers.
:::

## Finding locations likely to be inland ports using Earth Engine

![](./Images/PortPic.png){width=70%}

![](./Images/PortMap.png){width=70%}


::: {.notes}
- The US has 12 major inland ports and over 100 smaller inland ports. Can we use Earth Engine to create a method that locates places likely to have a major port?
- Let's assume that ports will:
  1. Be located at the nexus of major rivers and highways. This seems like a fair assumption since you have to get the containers into and out the ship.
  2. Be located in reasonably big cities.
:::

## Viewing highways {auto-animate=true}

```javascript
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");
```

::: {.notes}
This line loads the US census bereau's 2016 TIGER dataset. This dataset is a collection of Features. Or a "FeatureCollection". In google earth engine a feature is a data structure that represents a geographic object and properties associated with that object. FeatureCollections usually store vector data. Each object in a FeatureCollection typically contains geometry (point, line, polygon) and attributes associated with that geometry. In this case a road could be represented by a line and an attributes could be the road type and road name.
:::

## Viewing highways {auto-animate=true}

```javascript
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));
```

::: {.notes}
This next line filters the "roads" FeatureCollection by the 'mtfcc' property. Each road has a string associated with 'mtfcc' that tells us if it is a highway, interstate, local road etc. By using the string 'S1100' we can select just the interstates from the roads data. This allows us to create an "interstates" feature collection.
:::

## Viewing highways {auto-animate=true}

```javascript
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');
```

::: {.notes}
These next two lines display the geometries in the "interstates" FeatureCollection that we have created. First we center the map pane on the US. Then we use the Map.addLayer method to plot all the geometries in "interstates" on the map as a layer called "Interstates". We also choose to color the interstates data green.
:::

## Adding streams {auto-animate="true"}

```{.javascript code-line-numbers="4-6"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds = 
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');
```

::: {.notes}
To incorporate stream data we need to add another FeatureCollection that has the flow-lines of the nations streams. We're going to use the hydrosheds database because it is the dataset of river reaches that is included in the Earth Engine Catalog.
:::

## Adding streams {auto-animate="true"}

```{.javascript code-line-numbers="4-6,11-14"} 
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');
```

::: {.notes}
The HydroSHEDS dataset includes many small streams and is a global dataset. We can create a new FeatureCollection that is just the large streams in the United States. To do this we apply two filters to the dataset. One "ee.Filter.eq" searches through the 'COUNTRY' property of the feature collection and removes features where 'COUNTRY' isn't equal to "United States". The other filter "EE.Filter.lte" searches through the "RIV_ORD" property of all the features and only keeps features with a river order less than or equal to 4. Here river order is assocated with the average discharge flowing through the streams with larger river order numbers equating to more discharge. 
:::

## Adding streams {auto-animate="true"} 

```{.javascript code-line-numbers="22-29"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');
```
::: {.notes}
Now that we've filtered out all the small streams lets visualize what's left. To do that we first create an object called "streamsVis". This allows us to assign all the visualization parameters that we will use to a single object so that we don't have to list them all in the second argument of the "Map.addLayer" method. This time instead of setting just the color of the geometries in the layer we also set the line width that the geometries will be displayed with.  
:::

## Finding intersection points {auto-animate="true"} 

```{.javascript code-line-numbers="16-27"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');
```

::: {.notes}
Now that we have FeatureCollections representing both major interstates and major rivers in the United States let's use these to create our first list of candidate port locations by using the assumption that a port will be located near the intersection of a major highway and river. To do this we have to find the places that interstates and rivers intersect. 

We'll find these intersection points by performing a spatial join between the interstates and filteredStreams datasets. A spatial join is a way of combining two datasets based on their spatial relationship with one another. 

var join = ee.Join.simple(); creates a simple join object. In a simple join, all features in the primary (first) collection that match any feature in the secondary (second) collection are included in the output. 

var filter = ee.Filter.intersects({leftField: '.geo', rightField: '.geo'}); defines the type of spatial relationship that should exist for a match to be valid in the join. In this case, the .intersects filter means features must intersect each other to be considered a match. The 'leftField' and 'rightField' are set to '.geo', meaning it's the geometry field of each feature being considered for the intersection.

var intersectionLines = join.apply(filteredStreams, interstates, filter); applies the join using the filteredStreams FeatureCollection as the primary collection, the interstates FeatureCollection as the secondary collection, and the intersection filter. The result will be a new FeatureCollection where each feature is a stream from filteredStreams that intersects an interstate from interstates. The properties of each feature in this output collection will be a combination of the properties of the intersecting stream and interstate features.
:::

## Finding intersection points {auto-animate="true"} 

```{.javascript code-line-numbers="29-41"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');
```

::: {.notes}
We wanted to find intersection points. The join that we performed gives us stream line segments that intersect interstates. To get to points lets create a function that converts the stream line segments into points. Before we do this we select a subset of lines from "intersectionLines" because examining all the intersectionLines ends up being slow (we're going to experiment with different ways to fix this tomorrow). Then we create a function called "lineToPoint" line to point takes a feature with a line geometry and then gets the centroid of that geometry. It then casts this centroid to an earth engine Feature by using the centroid point as the geometry for the new feature and appending the properties of the inputted line feature using the "feature.toDictionary" method.
:::

## Finding intersection points {auto-animate="true"} 

```{.javascript code-line-numbers="43-49"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');
```

::: {.notes}
To actually obtain a FeatureCollection of intersection points we now *map* this function onto the selectedLines FeatureCollection. The map function takes in the lineToPoint function and applies it to each feature in the 'selectedLines' FeatureCollection. This creates another FeatureCollection that is intersection points instead of intersection lines. We then convert these points into a list called "pointsList" this will come in handy later when we are trying to select intersection points that are located in areas with a high population density.
:::

## Viewing intersection points {auto-animate="true"} 

```{.javascript code-line-numbers="66-71"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
Now let's display intersectionPoints as a layer on the map (run this code and show the intersection points). Note that we have a now layer attribute "pointSize" that is specific to the point geometry.
:::

## Bringing in population density

![](./Images/AlabamaDens.png)

Going to add the following line:

```javascript
// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");
//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();
```

::: {.notes}
We now have intersection points of where rivers intersect interstates. However, ports are normally in cities. To create a method that is able to suggest candidate port locations with high likelihood we should filter out intersection points that aren't located in areas with a relatively high population density. To do this we will bring in NASA's Gridded Population of the World dataset. Note that this is a raster dataset and so is different than the vector geometries that we have been working with up until now. This means that the population density raster images are stored in an ImageCollection instead of a FeatureCollection. An ImageCollection is made up of a one or more images usually from different time periods. Each image in the collection can cover different spatial areas and can have multiple bands with different types of data. The images in the GPW dataset only have one band with the name "population_density". Each pixel in this band ranges from 0 to about 800k. This ImageCollection has images from multiple years. To get only one year we filter the popDens ImageCollection by a date range and then take the first image that is available in that date range. 
:::

## Sampling population densities {auto-animate="true"} 

```{.javascript code-line-numbers="57-67"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
The first step to sampling the population densities is to create a region around each intersection point so that we can obtain a representative population density value for each point. In earth engine the region around each point that we will create is called a "buffer". We also want to assign a unique index to each buffered point so that we can identify which intersection points have high population densities and which ones have low densities later on in the script.

To create the buffer and set the id we will create a function called "bufferAndSetID". This function takes a single index value in as input. It then uses that value to get a point out of the list of point Features in pointsList. It then creates a circular buffer around that point with a radius of 10km using the buffer method. This creates a variable called "bufferedPoint". We then assigne this bufferedPoint an ID that corresponds to the index of the point in the pointsList that the bufferedPoint was created from. The function then returns this final "bufferedPointWithID" value.  
:::

## Sampling population densities {auto-animate="true"} 

```{.javascript code-line-numbers="69-77"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
We now apply the "bufferAndSetID" function we just created to our pointsList. To do this we furst need to create a sequence of numbers that will correspond to the id's we will assign to each bufferedPoint. We then map the "bufferAndSetID" function onto each id. Remember each id corresponds to an index that refers to each intersectionPoint we are examining. This allows us to create a new list of bufferedPoints that is tagged with an id that links it to each intersectionPoint. We then turn this list of bufferedPoints into a FeatureCollection using the ee.FeatureCollection method. 
:::

## Sampling population densities {auto-animate="true"} 

```{.javascript code-line-numbers="79-86"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
We'll now use our bufferedPoints geometries (these geometries are now circles instead of true points since they were expanded in the buffering process) to select sub-regions of the population density image around the intersection points. The first line uses the MultiPolygon method to create a geometry that represents the collection of circles around our intersection points. This multipolygon geometry is then used to clip the population density image.
:::

## Sampling population densities {auto-animate="true"} 

```{.javascript code-line-numbers="88-105"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
Now let's define a function that allows us to sample pixels of the population density image inside of the buffered circles around each intersection point.

To do this we create a samplePoints function that takes in a bufferedPoint (the feature in the input argument) . The geometry from the buffered point feature is used to demarcate a boundary from which 10 random points locations are sampled. These locations are then used to get the population density values at each sample location using the 'sampleRegions' method. The 10 population density values from each buffered region are then assigned an ID corresponding to the ID of the buffered points from which they were sampled.

Finally we now map this samplePoints function onto bufferedPoints. This gives us a feature collection of feature collections. Each sub feature collection is a collection of 10 randomly sampled population density values within each circular buffer area as well as the bufferedpointID that the population density value was sampled from assigned as a property to each point feature. The sub-FeatureCollections are then flattened into a single FeatureCollection of point features using the "flatten" method.
:::

## Finding mean population densities {auto-animate="true"} 

```{.javascript code-line-numbers="107-118"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Define a reducer that calculates the mean 'population_density'
var meanReducer = ee.Reducer.mean();

// Group the 'sampledPoints' FeatureCollection by 'BufferedAreaID' 
// and calculate the mean 'population_density' for each group
var meanPopDens = sampledPoints.reduceColumns({
  reducer: meanReducer.group({
    groupField: 0,
    groupName: 'BufferedAreaID',
  }),
  selectors: ['BufferedAreaID', 'population_density']
});

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```

::: {.notes}
We can now calculate the mean sampled population density of each buffered point area by creating a reducer object that uses the "mean" method to calculate the average of a set of numbers and return that average values as a "reduced" representative value of that set of numbers.

Next we use the meanReducer object we just created as the reducer in the reduceColumns function that we are applying to the features inside of the sampledPoints featureCollection. The group function is used on the reducer to dicatate which property we want to group the features in the featureCollection by. In this case we want to group the features into different columns according to their bufferedAreaID and then take the average of those columns. The 'groupField' takes as input the index of the property inside of the features "property" list. 'groupName' specifies the name of of the output property that each reduced value will be assigned to. 

Finally, selectors specifies which properties are going to be used in the reducing process. 'BufferedAreaID' is the property that we are reducing by so it is a 'selector'. 'population_density' is the property being reduced so it is also a selector.

The output, meanPopDens, will be an ee.Dictionary where each entry represents a distinct 'BufferedAreaID' and its associated mean population density. 
:::


## Filtering out low density intersections {auto-animate="true"} 

```{.javascript code-line-numbers="120-134"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Define a reducer that calculates the mean 'population_density'
var meanReducer = ee.Reducer.mean();

// Group the 'sampledPoints' FeatureCollection by 'BufferedAreaID' 
// and calculate the mean 'population_density' for each group
var meanPopDens = sampledPoints.reduceColumns({
  reducer: meanReducer.group({
    groupField: 0,
    groupName: 'BufferedAreaID',
  }),
  selectors: ['BufferedAreaID', 'population_density']
});

// Transform the output of the reduceColumns method
// to a FeatureCollection
var meanPopDensList = ee.List(meanPopDens.get('groups'));
var meanPopDensFC = ee.FeatureCollection(
                          meanPopDensList.map(function(el)
                                      {
                                        var dict = ee.Dictionary(el);
                                        return ee.Feature(null, dict);
                                      }));

// Filter the meanPopDensFC by the 'mean' property
var filteredMeanPopDens = meanPopDensFC.filter(
                                              ee.Filter.gt(
                                                'mean', 100)
                                              );

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```

::: {.notes}
Now that we have a mean, representative population density for each buffered zone around our intersection points lets filter out low density intersections. To do this we first need to transform the output of our reduceColumns operation to a featureCollection. This transformation is done by casting meanPopDens to a list of dictionary elements that is organized by the "groups" in the meanPopDens ee.Dictionary. Remember that each group in meanPopDens is a mean population value assigned to a key that represents the ID of the intersection point from which it was sampled around.

This list is then cast to a FeatureCollection using the ee.FeatureCollection function. This is done by mapping a function that takes a dictionary element "el" in the meanPopDensList and then does first does two things:
1. makes sure that the element is a actually an ee.Dictionary element by casting it as one.
2. Creating a new feature that has a "null" geometry and has the properties outlined in the key, value combinations of the dictionary. 
   
Now that meanPopDensFC is a feature collection we can call the filter function and apply it to the collection. Here the we use the "gt" or greater than filter and apply it to the "mean" property of each feature in the FeatureCollection. This gets rid of all the features that have mean population density values lower than 100.
:::

## Filtering out low density intersections {auto-animate="true"} 

```{.javascript code-line-numbers="136-140"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Define a reducer that calculates the mean 'population_density'
var meanReducer = ee.Reducer.mean();

// Group the 'sampledPoints' FeatureCollection by 'BufferedAreaID' 
// and calculate the mean 'population_density' for each group
var meanPopDens = sampledPoints.reduceColumns({
  reducer: meanReducer.group({
    groupField: 0,
    groupName: 'BufferedAreaID',
  }),
  selectors: ['BufferedAreaID', 'population_density']
});

// Transform the output of the reduceColumns method
// to a FeatureCollection
var meanPopDensList = ee.List(meanPopDens.get('groups'));
var meanPopDensFC = ee.FeatureCollection(
                          meanPopDensList.map(function(el)
                                      {
                                        var dict = ee.Dictionary(el);
                                        return ee.Feature(null, dict);
                                      }));

// Filter the meanPopDensFC by the 'mean' property
var filteredMeanPopDens = meanPopDensFC.filter(
                                              ee.Filter.gt(
                                                'mean', 100)
                                              );

// Get the list indices of the points with a
// population density greater than 100 people per sq km
var filteredIds = filteredMeanPopDens.aggregate_array(
                                      'BufferedAreaID'
                                      );

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```

::: {.notes}
Now we have a new feature collection "filteredMeanPopDens" that only has features with mean population_densities greater than 100. We can extract the intersection point ID's associated with these areas by using the "aggregate_array" function. This function returns an array of the "BufferedAreaID" values found in "filteredMeanPopDens"
:::

## Filtering out low density intersections {auto-animate="true"} 

```{.javascript code-line-numbers="142-147"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Define a reducer that calculates the mean 'population_density'
var meanReducer = ee.Reducer.mean();

// Group the 'sampledPoints' FeatureCollection by 'BufferedAreaID' 
// and calculate the mean 'population_density' for each group
var meanPopDens = sampledPoints.reduceColumns({
  reducer: meanReducer.group({
    groupField: 0,
    groupName: 'BufferedAreaID',
  }),
  selectors: ['BufferedAreaID', 'population_density']
});

// Transform the output of the reduceColumns method
// to a FeatureCollection
var meanPopDensList = ee.List(meanPopDens.get('groups'));
var meanPopDensFC = ee.FeatureCollection(
                          meanPopDensList.map(function(el)
                                      {
                                        var dict = ee.Dictionary(el);
                                        return ee.Feature(null, dict);
                                      }));

// Filter the meanPopDensFC by the 'mean' property
var filteredMeanPopDens = meanPopDensFC.filter(
                                              ee.Filter.gt(
                                                'mean', 100)
                                              );

// Get the list indices of the points with a
// population density greater than 100 people per sq km
var filteredIds = filteredMeanPopDens.aggregate_array(
                                      'BufferedAreaID'
                                      );

// Get intersection points with high density
var highDensityPoints = ee.FeatureCollection(
                              filteredIds.map
                                  (function(id) {
                                     return pointsList.get(id);
                                    }));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

```
::: {.notes}
Finally we can now locate which intersectionPoints are in areas of high density. We do this by mapping a function that takes an ID as an argument and then uses that as an index into the list of intersection point features we created at the beginning of the script.
:::


## Display port candidates {auto-animate="true"} 

```{.javascript code-line-numbers="171-176"}
// Load road data from US census bureau 
var roads = ee.FeatureCollection("TIGER/2016/Roads");

// Load the WWF HydroSHEDS Free Flowing Rivers Network v1 dataset
var hydrosheds =
ee.FeatureCollection("WWF/HydroSHEDS/v1/FreeFlowingRivers");

// Load the population density data
var popDens = ee.ImageCollection("CIESIN/GPWv411/GPW_Population_Density");

// Select just interstates using the MTFCC code
var interstates = roads.filter(ee.Filter.eq('mtfcc', 'S1100'));

// Filter out streams with an order less than 4
var filteredStreams = 
      hydrosheds.filter(ee.Filter.lte('RIV_ORD', 4))
                .filter(ee.Filter.eq('COUNTRY','United States'));

//Take the 1st population density map within the given date arange
var popDensYear = popDens.filter(ee.Filter.date('2010-01-01', '2019-12-31')).first();

// Perform a spatial join between filteredStreams
// and interstates FeatureCollections
var join = ee.Join.simple();
var filter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

var intersectionLines = join.apply(
                              filteredStreams, 
                              interstates,
                              filter);

// Sort by a random number and select the first N features
var selectedLines = intersectionLines.sort('random').limit(10);

// Function to convert line geometry to a point 
var lineToPoint = function(feature) {
  // Get the geometry
  var geom = feature.geometry();
  // Get the centroid of the geometry
  var centroid = geom.centroid();
  // Create a new point feature
  var pointFeature = ee.Feature(centroid, feature.toDictionary());
  return pointFeature;
};

// Apply the lineToPoint function to each element
// in intersectionPoints
var intersectionPoints = selectedLines.map(lineToPoint);

// Convert the intersectionPoints FeatureCollection to a List
var pointsList = intersectionPoints
                              .toList(intersectionPoints.size());

// Function to buffer a point and set an ID
var bufferAndSetID = function(index) {
  // Get the point
  var point = ee.Feature(pointsList.get(index));
  // Buffer the point
  var bufferedPoint = point.buffer(10000);
  // Set the ID
  var bufferedPointWithID = bufferedPoint.set('ID', index);
  // Return the buffered point with ID
  return bufferedPointWithID;
};

// Create a sequence of numbers to use as IDs
var ids = ee.List.sequence(
                           0,
                           intersectionPoints.size().subtract(1)
                          );

// Create a buffer at every intersection points
// using the id's you just created
var bufferedPoints = ee.FeatureCollection(ids.map(bufferAndSetID));

// Merge the buffered geometries
var bufferedGeometries = ee.Geometry
                           .MultiPolygon(bufferedPoints
                                          .geometry()
                                          .coordinates());

// Clip the population density image to the buffered geometries
var popDensYearBuffered = popDensYear.clip(bufferedGeometries);

// Function to sample random points within each buffered area
var samplePoints = function (feature) {
  var geometry = feature.geometry();
  var randomPoints = ee.FeatureCollection.randomPoints(geometry, 10);
  var sampledPoints = popDensYearBuffered.sampleRegions({
    collection: randomPoints,
    scale: 1000,
    tileScale: 16
  })
  // Add the buffered area ID to each sampled point
  sampledPoints = sampledPoints.map(function(point) {
    return point.set('BufferedAreaID', feature.get('ID'));
  });
  return sampledPoints;
};

// Sample 10 random points within each buffered area
var sampledPoints = bufferedPoints.map(samplePoints).flatten();

// Define a reducer that calculates the mean 'population_density'
var meanReducer = ee.Reducer.mean();

// Group the 'sampledPoints' FeatureCollection by 'BufferedAreaID' 
// and calculate the mean 'population_density' for each group
var meanPopDens = sampledPoints.reduceColumns({
  reducer: meanReducer.group({
    groupField: 0,
    groupName: 'BufferedAreaID',
  }),
  selectors: ['BufferedAreaID', 'population_density']
});

// Transform the output of the reduceColumns method
// to a FeatureCollection
var meanPopDensList = ee.List(meanPopDens.get('groups'));
var meanPopDensFC = ee.FeatureCollection(
                          meanPopDensList.map(function(el)
                                      {
                                        var dict = ee.Dictionary(el);
                                        return ee.Feature(null, dict);
                                      }));

// Filter the meanPopDensFC by the 'mean' property
var filteredMeanPopDens = meanPopDensFC.filter(
                                              ee.Filter.gt(
                                                'mean', 100)
                                              );

// Get the list indices of the points with a
// population density greater than 100 people per sq km
var filteredIds = filteredMeanPopDens.aggregate_array(
                                      'BufferedAreaID'
                                      );

// Get intersection points with high density
var highDensityPoints = ee.FeatureCollection(
                              filteredIds.map
                                  (function(id) {
                                     return pointsList.get(id);
                                    }));

// Center the map on the continental USA
Map.setCenter(-98.5833, 39.8333, 5);

// Display the filtered FeatureCollection
Map.addLayer(interstates, {color: 'green'}, 'Interstates');

// Set visualization parameters
var streamsVis = {
  color: 'blue',
  width: 1
};

// Add the filtered streams to the map
Map.addLayer(filteredStreams, streamsVis, 'Filtered Streams');

// Add the filtered intersection points to the map
Map.addLayer(
             intersectionPoints,
             {color: 'yellow',pointSize: 10},
             'Filtered Intersection Points'
             );

// Display the filtered intersection points in red
Map.addLayer(
            highDensityPoints,
            {color: 'red', pointSize: 10},
            'High Density Intersection Points'
            );

```

::: {.notes}
Now that we have our high density intersection points we can now display candidate port locations as a different color than the rest of the intersection points.
:::
